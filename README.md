# Знакомство с DAST v5.0

## Начальные условия
Аналогичны [SAST Labs](https://gitlab.basealt.space/kuznetsovam/sast-labs) и рекомендуют (хотя и не требуют) предварительного выполнения последних.

## Часть 1. Запуск фаззинга
[AFLplusplus](https://github.com/AFLplusplus/AFLplusplus) - фаззер с открытым исходным кодом, распространяющийся под лицензией Apache-2.0.

Для знакомства с процессом фаззинга предлагается запустить фаззинг-тестирование с помощью AFLplusplus для одной из двух утилит командной строки:
- Вариант 1. [tar](https://www.gnu.org/software/tar/) - утилита GNU Project для создания архивов
- Вариант 2. [gzip](https://www.gnu.org/software/gzip/) - утилита GNU Project для сжатия файлов

В ходе выполнения заданий 1 части у нас должны получиться следующие артефакты работы:
- скриншоты выполнения пунктов задания;
- скриншоты запущенного процесса AFLplusplus;
- директории input/ и out/ со входными и сгенерированными фаззером файлами.

### Настройка окружения
#### Установка AFLplusplus
Установим AFLplusplus и его зависимости:
```shell
sudo apt-get install AFLplusplus llvm15.0
```

#### Установка зависимостей проекта
Требуется найти исходный код выбранной утилиты (например, на https://git.altlinux.org/gears/) и подготовить окружение согалсно требованиям (для помощи можно воспользоваться spec-файлом, использующимся при сборке).

### Сборка с инструментацией
Для сборки под контролем компилятора AFLplusplus предлагается добавлять переменные окружения `CC=afl-clang-lto CXX=afl-clang-lto++` перед командами сборки, например:
```shell
CC=afl-clang-lto CXX=afl-clang-lto++ make
```
Требуется выполнить таким образом сборку выбранной утилиты.

### Запуск фаззинг-тестирования
Создадим директорию для входных данных:
```shell
mkdir input
```
Поскольку AFLplusplus требуется хотя бы один входной фазапуск утилиты производится надйл для запуска, создадим тестовый файл:
```shell
echo "test" > input/1
```
С помощью команды `afl-fuzz` запустим фаззинг нашей программы (изменив program на наш исполняемый файл: gzip или tar)
Используемые ключи и опции:
- `-i` - путь к директории со входным корпусом;
- `-o` - путь к директории результатов работы фаззера (будет создана, если ее не было).
- `[...program's cmdline...]` - опции запуска утилиты tar/gzip. Требуется определить опции, которые позволят выполнять запуск утилиты над произвольным файлом
- `@@` - поскольку обе утилиты получают на вход файлы, вместо @@ AFLplusplus будет подставлять автосгенерированное название этого файла
```shell
afl-fuzz -i input/ -o out/ -- ./program [...program's cmdline...] @@
```

### Итог 1 части
В ходе 1 части мы научились запускать фаззинг-тестирование для утилит командной строки.

## Часть 2. Добавление входного корпуса и словаря
Важным элементом фаззинг-тестирования является правильная подготовка входного корпуса и словаря, на основе которого будет происходить генерация новых тест-кейсов.

Для знакомства с процессом подготовки входного корпуса для фаззинга предлагается запустить фаззинг-тестирование с помощью AFLplusplus для одной из двух утилит командной строки:
- Вариант 1. [xmlstarlet](https://sourceforge.net/p/xmlstar/code/ci/master/tree/) - утилита для работы с XML.
- Вариант 2. [jq](https://github.com/jqlang/jq) - утилита для работы с JSON.

В ходе выполнения заданий 2 части у нас должны получиться следующие артефакты работы:
- скриншоты выполнения пунктов задания;
- скриншоты запущенного процесса AFLplusplus;
- директория input/ содержащая как минимум 3 подготовленных примера входных файлов, обрабатываемых программой.
- подготовленный словарь, содержащий примеры синтаксиса обрабатываемых программой файлов.
- директория out/ со сгенерированными фаззером файлами.

## Часть 3. Дедупликация, триаж и сбор покрытия
Для оценки результатов фаззинг-тестирования требуется:
- собрать покрытие кода, достигаемое выбранной нами стратегией фаззинга
- провести анализ сгенерированных падений (crashes) и зависаний (hangs)

В ходе выполнения заданий 3 части у нас должны получиться следующие артефакты работы:
- скриншоты выполнения пунктов задания;
- сгенерированный HTML-отчет с анализом покрытия проекта из части 2;
- скриншоты запущенного процесса фаззинга libvirt с помощью AFLplusplus;
- директория casr-out, содержащая результаты анализа утилитой CASR;
- скриншот анализа указанной сработки с помощью casr-cli;
- патч, исправляющий вызвавшую падение ошибку;


### Сбор покрытия
Для сбора покрытия воспользуемся средствами сбора покрытия, входящими в проект llvm: https://clang.llvm.org/docs/SourceBasedCodeCoverage.html
В качестве примера используется проект cppcheck

Требуется пересобрать исследуемый в части 2 проект с инструментацией для сбора покрытия:
```
CFLAGS="-fprofile-instr-generate -fcoverage-mapping" CXXFLAGS="-fprofile-instr-generate -fcoverage-mapping" CC=clang CXX=clang++ cmake .
CFLAGS="-fprofile-instr-generate -fcoverage-mapping" CXXFLAGS="-fprofile-instr-generate -fcoverage-mapping" CC=clang CXX=clang++ make
```

Определить место хранения файлов, использующихся для сбора покрытия:
```
mkdir cov
cd cov
export LLVM_PROFILE_FILE="$(pwd)/cppcheck.profraw"
```

Затем запустить исследумый проект подавая на вход все наработанные в ходе 5-минутного фаззинг-тестирования файлы:
```
./bin/cppcheck $(find "output/default/queue" -type f) 2>&1 > /dev/null
```

Проиндексировать сгенерированный профиль:
```
llvm-profdata merge -sparse cov/cppcheck.profraw -o cov/cppcheck.profdata
```

Экспортировать в формат lcov:
```
llvm-cov export -format=lcov -instr-profile=cov/cppcheck.profdata ./bin/cppcheck > cov/cppcheck.lcov
```

Сгенерировать HTML-отчет
```
genhtml cov/cppcheck.lcov -o cov/html
```

### Дедупликация и триаж
Поскольку у нас нет возможности быстро накопить большой корпус падений, для которого нужно было бы проводить триаж и дедупликацию, для знакомства с дедупликацией и триажом наработанных срабатываний воспользуемся инструкцией по фаззинг-тестированию libvirt, с помощью которого была обнаружена уязвимость CVE-2024-1441.
Инструкция доступна по ссылке: https://www.altlinux.org/Libvirt_fuzzing_technique
Требуется выполнить инструкции до блока Run fuzzing (включительно).

После запуска фаззинга libvirt, предлагается проанализировать наработанные за 90 дней работы данного фаззинг-теста падения, находящиеся в директории afl-out/

Для этого воспользуемся утилитой CASR.
Установим её:
```shell
# For ALT Linux
sudo apt-get install casr

# For other distros
git clone https://github.com/ispras/casr
cd casr
cargo build --release
```

Запустим анализ (обратите внимание на возможную необходимость корректировки путей):
```shell
export LD_PRELOAD=" /fuzz/preeny/src/desock.so"

casr-afl -f -i /dast-labs/afl-out/ -o /dast-labs/casr-out -t 1
```

С помощью утилиты `casr-cli` найдите среди результатов анализа сработку в файле `src/interface/interface_backend_udev.c:225` - уязвимость, эксплуатирующая это падение впоследствии и получила идентификатор CVE-2024-1441.
Подготовьте патч, исправляющий ошибку, приводящую к укзанному падению.

Дополнительно:
- Попробуйте проанализировать и исправить другие прошедшие дедупликацию сработки.

## Часть 4. Обертки, persistent mode и libfuzzer
Помимо фаззинга приложения через "толстый вход" как единого целого (whole application fuzzing), часто используется фаззинг конкретных функций, для чего разрабатываются фаззинг-обертки.
Для увеличения скорости фаззинг-тестирования также используются различные дополнительные инструменты, в том числе [persistent mode AFL++](https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md) ([типовой пример использования всех функций persistent mode](https://github.com/AFLplusplus/AFLplusplus/blob/stable/utils/persistent_mode/persistent_demo_new.c))

В ходе выполнения данной части предлагается:
- разработать фаззинг-обертку для выделенной функции, запустить и зафиксировать скорость фаззинга;
- добавить shared memory fuzzing, запустить и зафиксировать скорость фаззинга;
- добавить deferred init, запустить и зафиксировать скорость фаззинга;
- добавить persistent mode, запустить и зафиксировать скорость фаззинга;
- переписать обертку под использование libfuzzer, запустить и зафиксировать скорость фаззинга;
- пересобрать libfuzzer-обертку с использованием AFL++, запустить и зафиксировать скорость фаззинга.

Важно отметить, что скорость фаззинга не является абсолютным показателем и, очевидно, зависит от множества вещей, в том числе производительности конкретной системы. В данном задании мы используем скорость не как абсолютный показатель качества, а как относительный показатель, сравнивая значения которого между собой можно получить некую информацию об эффективности применяемых методов

Варианты:
1. [nlohmann-json](https://github.com/nlohmann/json), функция parse;
2. [tinyxml2](https://github.com/leethomason/tinyxml2), функция Parse.

В ходе выполнения заданий 3 части у нас должны получиться следующие артефакты работы:
- скриншоты запущенного фаззинга на каждой итерации;
- код оберток на каждой итерации;
- общая информация по скорости фаззинга на каждой итерации.

### Обертки
Для фаззинга конкретной функции разрабатывается файл wrapper.cpp, который принимает на вход (через cin) данные от фаззера. Чтобы определить их размер можем воспользоваться `vector`, что не очень оптимально, но подходит для демонстрации.

Здесь и далее в качестве примера используется фаззинг функции `load_buffer()` из проекта [pugixml](https://github.com/zeux/pugixml). Запишем полученные из `cin` данные в `buffer`, который затем передадим на вход функции `load_buffer()`:
```cpp
#include "src/pugixml.hpp"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <vector>


int main() {
    std::vector<char> buffer(std::istreambuf_iterator<char>(std::cin), {});
	pugi::xml_document doc;
	doc.load_buffer(buffer.data(), buffer.size());
	return 0;
}
```
Для сборки этой цели необходимо использовать компилятор из состава AFL++:
```shell
afl-clang-lto++ wrapper.cpp src/pugixml.cpp -o wrapper
```

### Shared memory fuzzing
Ускорим фаззинг путем загрузки входных данных из разделяемой памяти, без необходимости чтения cin. Для этого воспользуемся shared memory возможностями AFL++.

Добавим инициализацию разделяемой памяти (`__AFL_FUZZ_INIT()`) и присвоим уже использованным переменным новые значения (`__AFL_FUZZ_TESTCASE_BUF` и `__AFL_FUZZ_TESTCASE_LEN`):
```cpp
[...]

__AFL_FUZZ_INIT();

int main() {
    unsigned char *data = __AFL_FUZZ_TESTCASE_BUF;
    ssize_t size = __AFL_FUZZ_TESTCASE_LEN;
    [...]
    doc.load_buffer(data, size);
    [...]
}
```

### Deferred init
Для ускорения фаззинга можно также отложить момент форка нового процесса. В нашем случае это будет не так полезно, поскольку никакой сложной инициализации перед вызовом функции `load_buffer()` не требуется, но тем не менее добавим указание на момент, до которого можно отложить форк (`__AFL_INIT()`):
```cpp
[...]
int main() {

    __AFL_INIT();

    unsigned char *data = __AFL_FUZZ_TESTCASE_BUF;
    [...]
}
```

### Persistent mode
Наконец, можно разрешить повторять вызов функции большее количество раз без необходимости каждый раз создавать форк процесса. Для этого добавим цикл, вызывающий функцию без форка процесса (`while (__AFL_LOOP(UINT8_MAX))`):
```cpp
[...]

int main() {

    __AFL_INIT();

    while (__AFL_LOOP(UINT8_MAX)) {
        [...]
    }

    return 0;
}
```

### Libfuzzer
Для написания [libfuzzer](https://llvm.org/docs/LibFuzzer.html)-обертки функция `main` заменяется на `extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {...}`:
```cpp
#include "src/pugixml.hpp"
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size){
    pugi::xml_document doc;
    doc.load_buffer(data, size);
	return 0;
}
```

Поскольку libfuzzer является частью проекта LLVM, для сборки такой обертки используется обычный компилятор `clang++` с ключом `-fsanitize=fuzzer`, а фаззинг запускается путем простого исполнения получившегося бинарного файла

### AFL++ & Libfuzzer
Формат оберток libfuzzer по сути является стандартом для фаззинг-оберток, и AFL++ также [умеет с ним работать](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#g-libfuzzer-fuzzer-harnesses-with-llvmfuzzertestoneinput).

Убедитесь в этом, пересобрав libfuzzer-обертку компилятором afl-clang-lto++ с использованием того же ключа `-fsanitize=fuzzer`, а затем запустив фаззинг, как и в предыдущих примерах, с помощью `afl-fuzz`.

### Итог 4 части
В ходе выполнения заданий 4 части мы научились разрабатывать фаззинг-обертки для тестирования конкретных функций программы, а также изучили способы ускорения фаззинг-тестирования.

Также мы познакомились с новым фаззером - Libfuzzer, разработали обертку для его запуска и проверили её совместимость с уже известным нам AFL++.

## Часть 5. Минимизация корпуса, санитайзеры и многопоточный фаззинг
В этой части мы погружаемся в детали фаззинга, в том числе описанные в документации AFL++: [fuzzing in depth](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md)
Мы минимизируем входной корпус, рассмотрим сборку с санитайзерами и запуск фаззинга в несколько потоков.

В ходе выполнения данной части предлагается:
- минимизировать входной корпус из **части 2** и уменьшить размер оставшихся его элементов;
- собрать обертку для AFL++ из **части 4** с ASAN, MSAN, UBSAN;
- запустить многопоточный фаззинг с помощью AFL++ для всех получившихся исполняемых файлов;
- собрать обертку для libfuzzer из **части 4** с ASAN и UBSAN;
- запустить libfuzzer в несколько потоков.

В ходе выполнения заданий 5 части у нас должны получиться следующие артефакты работы:
- минимизированный корпус для проектов из **части 2**;
- скриншоты запущенного в несколько потоков фаззинга проекта из **части 4** с помощью AFL++;
- общая директория output, где хранятся результаты работы всех экземпляров фаззера;
- скриншоты запущенного фаззинга проекта из **части 4** в несколько потоков с помощью libfuzzer.

### Минимизация корпуса
#### Удаление элементов корпуса, не открывающих новые пути
Чтобы [сделать входной корпус уникальным](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#b-making-the-input-corpus-unique) используется утилита `afl-cmin`
Проверим на уникальность корпус, подготовленный нами в ходе выполнения части 3:
```shell
afl-cmin -i input -o input-unique -- ./program [...program's cmdline...] @@
```

#### Минимизация элементов корпуса
Для [уменьшения размера элементов корпуса](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#c-minimizing-all-corpus-files) используется утилита `afl-tmin`, которую необходимо вызывать отдельно для каждого файла

Минимизируем размер одного из полученных на предыдущем шаге файлов (на примере cppcheck из части 2):
```shell
afl-tmin -i input-unique/1.cpp -o input/1.cpp.min -- ./bin/cppcheck @@
```

Самостоятельно проверьте на уникальность подготовленный вами в части 2 корпус из 3 элементов, а затем уменьшите размер оставшихся файлов.

### Санитайзеры
[Санитайзеры](https://github.com/google/sanitizers) - инструменты комилятора, помогающие работать с программой (в том числе находить ошибки) с помощью допонительной инструментации. Мы уже использовали санитайзер сбора покрытия в части 3.

В рамках выполнения этого задания нам потребуются следующие санитайзеры:
- [AddressSanitizer (ASAN)](https://github.com/google/sanitizers/wiki/AddressSanitizer) (Для AFL++ - `AFL_USE_ASAN=1`, для libfuzzer - `-fsanitize=address`)
- [LeakSanitizer (LSAN)](https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer) (Включается вместе с ASAN)
- [MemorySanitizer (MSAN)](https://github.com/google/sanitizers/wiki/MemorySanitizer) (Для AFL++ - `AFL_USE_MSAN=1`, для libfuzzer - `-fsanitize=memory`)
- [UndefinedBehaviorSanitizer (UBSAN)](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html) Для AFL++ - `AFL_USE_UBSAN=1`, для libfuzzer - `-fsanitize=undefined`

AFL++ имеет собственные переменные окружения для облегчения использования санитайзеров (см. [selecting sanitizers](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#c-selecting-sanitizers)). Для фаззинга с их помощью соберем отдельные исполняемые файлы под каждый вид санитайзеров (на примере обертки под AFL++ для pugixml из части 4):
```shell
afl-clang-lto++ wrapper.cpp src/pugixml.cpp -o wrapper-clear
AFL_USE_ASAN=1 afl-clang-lto++ wrapper.cpp src/pugixml.cpp -o wrapper-asan
AFL_USE_MSAN=1 afl-clang-lto++ wrapper.cpp src/pugixml.cpp -o wrapper-msan
AFL_USE_UBSAN=1 afl-clang-lto++ wrapper.cpp src/pugixml.cpp -o wrapper-ubsan
```

Для фаззинга с помощью libfuzzer соберем исполняемый файл с ASAN и UBSAN (на примере обертки под libfuzzer для pugixml из части 4):
```shell
clang++ -fsanitize=fuzzer,address,undefined wrapper.cpp src/pugixml.cpp -o wrapper-libfuzzer
```

### Многопоточный фаззинг
#### Многопоточный фаззинг в AFL++
Для масштабирования фаззинг-тестирования приходится запускать процессы фаззинга используя [все доступные ядра](https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#c-using-multiple-cores)

Первый процесс будет основным - master-процессом, для его запуска добавляем к вызову `afl-fuzz` ключ `-M master`. Остальные процессы как правило называют slave-процессами и для них запуска используется ключ `-S <name>`. Главным для того, чтобы фаззеры работали параллельно и могли обмениваться корпусом является общая директория output, указываемая с флагом `-o`.

Запустите многопоточный фаззинг используя собранные с санитайзерами исполняемые файлы, полученные на предыдущем шаге. В результате должны быть запущены:
- master
- slave-clear (второй экземпляр, запущенный на "чистой" обертке)
- slave-asan (экземпляр, запущенный на обертке с ASAN)
- slave-msan (экземпляр, запущенный на обертке с MSAN)
- slave-ubsan (экземпляр, запущенный на обертке с UBSAN)

Если количество ядер не позволяет запустить сразу все указанные процессы, следует запустить мастер-процесс, а затем по очереди каждый из slave-процессов. Проверить свободные ядра можно, например, с помощью утилиты `afl-gotcpu`.

#### Многопоточный фаззинг в libfuzzer
Для запуска многопоточного фаззинга с помощью libfuzzer воспользуемся экспирементальным ключом `-fork=N`, где N-количество потоков, добавив этот ключ к вызову исполняемого файла.

### Итог 5 части
В ходе выполнения задач 5 части мы научились минимизировать входной корпус, рассмотрели сборку с санитайзерами и запуск фаззинга в несколько потоков.

## Changelog
* Mon Nov 25 2024 Alexander Kuznetsov <kuznetsovam@basealt.ru> v5.0
    - Добавлена 5 часть.

* Mon Nov 18 2024 Alexander Kuznetsov <kuznetsovam@basealt.ru> v4.0
    - Добавлена 4 часть.

* Mon Nov 11 2024 Alexander Kuznetsov <kuznetsovam@basealt.ru> v3.0
    - Добавлена 3 часть.

* Mon Oct 21 2024 Alexander Kuznetsov <kuznetsovam@basealt.ru> v2.1
    - Инвертированы варианты во 2 части.

* Mon Oct 21 2024 Alexander Kuznetsov <kuznetsovam@basealt.ru> v2.0
    - Добавлена 2 часть.

* Mon Oct 07 2024 Alexander Kuznetsov <kuznetsovam@basealt.ru> v1.0
    - Добавлена 1 часть.
